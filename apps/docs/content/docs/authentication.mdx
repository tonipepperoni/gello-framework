---
title: Authentication
description: Protect your API with tokens and sessions
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Steps, Step } from 'fumadocs-ui/components/steps';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

Authentication verifies who a user is. Gello provides two approaches:

- **API Tokens** — For APIs, mobile apps, and third-party integrations
- **Sessions** — For browser-based applications with cookies

## Quick Start

<Steps>
<Step>
### Install the package

```bash
pnpm add @gello/auth
```
</Step>

<Step>
### Protect your routes

```typescript
import { authenticate } from "@gello/auth"
import { Route, route } from "@gello/platform-node"

const protectedRoutes = Route.group({
  middleware: [authenticate()],
}, [
  route.get("/me", getCurrentUser),
  route.get("/settings", getSettings),
])
```
</Step>

<Step>
### Get the current user

```typescript
import { Auth } from "@gello/auth"

const getCurrentUser = Effect.gen(function* () {
  const user = yield* Auth.user()
  return json(user)
})
```
</Step>
</Steps>

## API Tokens

Tokens are the simplest way to authenticate API requests. Send them in the `Authorization` header:

```
Authorization: Bearer your-token-here
```

### Creating Tokens

```typescript
import { Auth } from "@gello/auth"

const createToken = Effect.gen(function* () {
  const user = yield* Auth.user()

  // Create a token that can read and write posts
  const { token } = yield* Auth.createToken(user.id, "My API Token", {
    scopes: ["posts:read", "posts:write"],
    expiresIn: "30 days",
  })

  // Return the token to the user — this is the only time they'll see it!
  return json({ token })
})
```

### Token Scopes

Scopes limit what a token can do:

```typescript
// Read-only token
yield* Auth.createToken(userId, "Reader", {
  scopes: ["posts:read", "comments:read"],
})

// Full access token
yield* Auth.createToken(userId, "Admin", {
  scopes: ["*"],  // Wildcard — can do anything
})
```

### Requiring Scopes

Protect routes that need specific permissions:

```typescript
import { authenticate, scopes } from "@gello/auth"

const writeRoutes = Route.group({
  middleware: [
    authenticate(),
    scopes("posts:write"),  // Requires this scope
  ],
}, [
  route.post("/posts", createPost),
  route.put("/posts/:id", updatePost),
])
```

### Listing & Revoking Tokens

```typescript
// List all tokens for a user
const tokens = yield* Auth.tokens(userId)

// Revoke a specific token
yield* Auth.revokeToken(tokenId)

// Revoke all tokens for a user
yield* Auth.revokeAllTokens(userId)
```

## Session Authentication

For browser apps, use sessions with cookies and CSRF protection:

```typescript
import { session, csrf } from "@gello/auth"

const webRoutes = Route.group({
  middleware: [session(), csrf()],
}, [
  route.get("/dashboard", dashboard),
  route.post("/settings", updateSettings),
])
```

### Login & Logout

```typescript
// Login
const login = Effect.gen(function* () {
  const { email, password } = yield* getJsonBody()

  const user = yield* Auth.attempt(email, password)

  // Create session
  yield* Auth.login(user)

  return json({ message: "Logged in" })
})

// Logout
const logout = Effect.gen(function* () {
  yield* Auth.logout()
  return json({ message: "Logged out" })
})
```

### CSRF Protection

Gello automatically validates CSRF tokens for session-authenticated requests. Your frontend should:

1. Get a CSRF token from the `XSRF-TOKEN` cookie
2. Send it in the `X-XSRF-TOKEN` header with each request

```javascript
// Frontend example
const token = getCookie('XSRF-TOKEN')

fetch('/api/settings', {
  method: 'POST',
  headers: {
    'X-XSRF-TOKEN': token,
  },
})
```

## Password Hashing

Never store passwords in plain text. Use the password hasher:

```typescript
import { Password } from "@gello/auth"

// Hash a password
const hash = yield* Password.hash(plainPassword)

// Verify a password
const valid = yield* Password.verify(plainPassword, hash)
```

## Checking Authentication

### In Handlers

```typescript
const handler = Effect.gen(function* () {
  // Get current user (throws if not authenticated)
  const user = yield* Auth.user()

  // Check if authenticated (returns boolean)
  const isLoggedIn = yield* Auth.check()

  // Get user or null
  const maybeUser = yield* Auth.userOrNull()
})
```

### Optional Authentication

For routes that work with or without authentication:

```typescript
const mixedRoutes = Route.group({
  middleware: [authenticate.optional()],
}, [
  route.get("/posts", listPosts),  // Shows public posts, or personalized if logged in
])
```

## Connecting to Your Database

Tell Gello how to find users:

```typescript
import { UserProvider } from "@gello/auth"

const MyUserProvider = UserProvider.make({
  findById: (id) => db.users.findById(id),
  findByEmail: (email) => db.users.findByEmail(email),
})

// Add to your app layer
const AppLayer = Layer.mergeAll(
  MyUserProvider,
  // ... other layers
)
```

## Error Handling

Authentication can fail for various reasons:

```typescript
const handler = Effect.gen(function* () {
  const user = yield* Auth.user()
  // ...
}).pipe(
  Effect.catchTags({
    AuthenticationError: () =>
      Effect.succeed(unauthorized({ error: "Please log in" })),

    TokenExpiredError: () =>
      Effect.succeed(unauthorized({ error: "Token expired" })),

    InsufficientScopeError: (e) =>
      Effect.succeed(forbidden({
        error: "Missing required permission",
        required: e.required,
      })),
  })
)
```

## Complete Example

```typescript
import { Effect } from "effect"
import { createApp, Route, route, json } from "@gello/platform-node"
import { authenticate, Auth, scopes } from "@gello/auth"

// Public routes
const publicRoutes = [
  route.post("/login", Effect.gen(function* () {
    const { email, password } = yield* getJsonBody()
    const user = yield* Auth.attempt(email, password)
    const { token } = yield* Auth.createToken(user.id, "Login")
    return json({ token })
  })),
]

// Protected routes
const protectedRoutes = Route.group({
  prefix: "/api",
  middleware: [authenticate()],
}, [
  route.get("/me", Effect.gen(function* () {
    const user = yield* Auth.user()
    return json(user)
  })),

  route.post("/tokens", Effect.gen(function* () {
    const user = yield* Auth.user()
    const { name, scopes } = yield* getJsonBody()
    const { token } = yield* Auth.createToken(user.id, name, { scopes })
    return json({ token })
  })),
])

// Admin routes
const adminRoutes = Route.group({
  prefix: "/admin",
  middleware: [authenticate(), scopes("admin")],
}, [
  route.get("/users", listAllUsers),
])

const app = createApp({ port: 3000 })
  .routes([
    ...publicRoutes,
    ...protectedRoutes,
    ...adminRoutes,
  ])
```

## Next Steps

- [Authorization](/docs/authorization) — Control what users can do
- [OAuth](/docs/oauth) — Let users sign in with GitHub, Google, etc.
- [Testing](/docs/testing) — Test authenticated routes
