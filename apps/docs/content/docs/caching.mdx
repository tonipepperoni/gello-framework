---
title: Caching
description: Speed up your app by storing data for quick retrieval
---

import { Callout } from 'fumadocs-ui/components/callout';

Caching stores frequently accessed data so you don't have to compute or fetch it repeatedly. Gello provides a simple, Laravel-inspired caching API.

## Basic Usage

```typescript
import { Cache } from "@gello/core"
import { Effect } from "effect"

const handler = Effect.gen(function* () {
  const cache = yield* Cache

  // Store a value for 30 minutes
  yield* cache.put("user:1", { name: "Alice" }, "30 minutes")

  // Get a value (returns Option)
  const user = yield* cache.get("user:1")

  // Delete a value
  yield* cache.forget("user:1")
})
```

## The Remember Pattern

The most useful caching pattern — get from cache, or compute and store:

```typescript
const getUser = (id: string) =>
  Effect.gen(function* () {
    const cache = yield* Cache

    return yield* cache.remember(
      `user:${id}`,
      "30 minutes",
      // Only runs if not in cache
      Effect.gen(function* () {
        const db = yield* Database
        return yield* db.users.findById(id)
      })
    )
  })
```

Now calls to `getUser("123")` will:
1. Check the cache for `user:123`
2. If found, return the cached value
3. If not found, query the database, cache the result, then return it

## Cache Operations

```typescript
const handler = Effect.gen(function* () {
  const cache = yield* Cache

  // Store values
  yield* cache.put("key", value)                    // Forever
  yield* cache.put("key", value, "1 hour")          // With expiration

  // Get values
  const result = yield* cache.get("key")            // Option<T>

  // Check if exists
  const exists = yield* cache.has("key")

  // Get and delete
  const pulled = yield* cache.pull("key")           // Gets then deletes

  // Delete
  yield* cache.forget("key")
  yield* cache.flush()                              // Clear everything

  // Increment/decrement numbers
  yield* cache.increment("counter")
  yield* cache.increment("counter", 5)
  yield* cache.decrement("counter")
})
```

## Cache Drivers

### Memory (Default)

Fast in-memory cache. Great for development and single-server deployments:

```typescript
import { MemoryCache } from "@gello/cache"

const CacheLive = MemoryCache.layer({
  maxSize: 1000,  // Evict oldest after 1000 entries
})
```

### Redis

For multi-server deployments — all servers share the same cache:

```typescript
import { RedisCache } from "@gello/cache"

const CacheLive = RedisCache.layer({
  url: process.env.REDIS_URL,
  prefix: "myapp:",
})
```

### File

Persist cache to disk:

```typescript
import { FileCache } from "@gello/cache"

const CacheLive = FileCache.layer({
  path: "/tmp/cache",
})
```

## Configuration

Set your cache driver via environment:

```bash
# .env
CACHE_DRIVER=redis
CACHE_PREFIX=myapp:
CACHE_TTL=3600

# Redis
REDIS_URL=redis://localhost:6379
```

## Invalidating Cache

When data changes, invalidate related caches:

```typescript
const updateUser = (id: string, data: UpdateData) =>
  Effect.gen(function* () {
    const cache = yield* Cache
    const db = yield* Database

    // Update the database
    const user = yield* db.users.update(id, data)

    // Invalidate the cache
    yield* cache.forget(`user:${id}`)

    return user
  })
```

## Tagged Cache

Group related cache entries for bulk invalidation:

```typescript
const cache = yield* Cache

// Store with tags
yield* cache.tags(["users"]).put("user:1", user)
yield* cache.tags(["users"]).put("user:2", user)
yield* cache.tags(["users", "admins"]).put("user:3", admin)

// Invalidate all entries with a tag
yield* cache.tags(["users"]).flush()  // Clears user:1, user:2, user:3
```

## Common Patterns

### Cache Database Queries

```typescript
const getPopularPosts = () =>
  Effect.gen(function* () {
    const cache = yield* Cache

    return yield* cache.remember("popular-posts", "10 minutes", () =>
      db.posts.findMany({
        orderBy: { views: "desc" },
        take: 10,
      })
    )
  })
```

### Cache API Responses

```typescript
const getWeather = (city: string) =>
  Effect.gen(function* () {
    const cache = yield* Cache

    return yield* cache.remember(`weather:${city}`, "1 hour", () =>
      fetch(`https://api.weather.com/current?city=${city}`)
        .then(r => r.json())
    )
  })
```

### Cache in Route Handlers

```typescript
const listUsers = Effect.gen(function* () {
  const cache = yield* Cache

  const users = yield* cache.remember("users:all", "5 minutes", () =>
    db.users.findMany()
  )

  return json(users)
})
```

## Testing

Use in-memory cache for fast tests:

```typescript
import { MemoryCache, NullCache } from "@gello/cache"

// Real caching in tests
const TestCacheLive = MemoryCache.layer()

// Or disable caching entirely
const NoCacheLive = NullCache.layer()
```

<Callout type="info">
For production, use Redis to share cache across multiple server instances.
</Callout>
