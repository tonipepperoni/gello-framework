---
title: Database
description: Connect to databases and run queries
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Steps, Step } from 'fumadocs-ui/components/steps';

Gello integrates with [Drizzle ORM](https://orm.drizzle.team/) for type-safe database access.

## Quick Start

<Steps>
<Step>
### Install Drizzle

```bash
pnpm add drizzle-orm pg
pnpm add -D drizzle-kit @types/pg
```
</Step>

<Step>
### Configure your connection

```bash
# .env
DATABASE_URL=postgresql://user:pass@localhost:5432/myapp
```
</Step>

<Step>
### Define your schema

```typescript
// src/db/schema.ts
import { pgTable, text, timestamp, boolean } from "drizzle-orm/pg-core"

export const users = pgTable("users", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  createdAt: timestamp("created_at").defaultNow(),
})

export const posts = pgTable("posts", {
  id: text("id").primaryKey(),
  title: text("title").notNull(),
  content: text("content"),
  published: boolean("published").default(false),
  authorId: text("author_id").references(() => users.id),
})
```
</Step>
</Steps>

## Setting Up the Database Layer

Create a database service that Gello manages:

```typescript
// src/db/index.ts
import { drizzle } from "drizzle-orm/node-postgres"
import { Pool } from "pg"
import { Effect, Layer, Context } from "effect"
import * as schema from "./schema"

class Database extends Context.Tag("Database")<
  Database,
  ReturnType<typeof drizzle>
>() {}

const DatabaseLive = Layer.scoped(
  Database,
  Effect.gen(function* () {
    const config = yield* Config
    const url = yield* config.string("DATABASE_URL")

    // Create pool that closes when app shuts down
    const pool = yield* Effect.acquireRelease(
      Effect.sync(() => new Pool({ connectionString: url })),
      (pool) => Effect.promise(() => pool.end())
    )

    return drizzle(pool, { schema })
  })
)
```

## Running Queries

### Select

```typescript
import { eq } from "drizzle-orm"

const listUsers = Effect.gen(function* () {
  const db = yield* Database

  const users = yield* Effect.tryPromise(() =>
    db.select().from(schema.users)
  )

  return json(users)
})

const getUser = Effect.gen(function* () {
  const db = yield* Database
  const id = yield* getParam("id")

  const [user] = yield* Effect.tryPromise(() =>
    db.select()
      .from(schema.users)
      .where(eq(schema.users.id, id))
  )

  if (!user) {
    return notFound({ error: "User not found" })
  }

  return json(user)
})
```

### Insert

```typescript
const createUser = Effect.gen(function* () {
  const db = yield* Database
  const body = yield* getJsonBody()

  const [user] = yield* Effect.tryPromise(() =>
    db.insert(schema.users)
      .values({
        id: crypto.randomUUID(),
        name: body.name,
        email: body.email,
      })
      .returning()
  )

  return created(user)
})
```

### Update

```typescript
const updateUser = Effect.gen(function* () {
  const db = yield* Database
  const id = yield* getParam("id")
  const body = yield* getJsonBody()

  const [user] = yield* Effect.tryPromise(() =>
    db.update(schema.users)
      .set({ name: body.name })
      .where(eq(schema.users.id, id))
      .returning()
  )

  return json(user)
})
```

### Delete

```typescript
const deleteUser = Effect.gen(function* () {
  const db = yield* Database
  const id = yield* getParam("id")

  yield* Effect.tryPromise(() =>
    db.delete(schema.users)
      .where(eq(schema.users.id, id))
  )

  return noContent()
})
```

## Transactions

Wrap multiple operations in a transaction:

```typescript
const transferMoney = Effect.gen(function* () {
  const db = yield* Database
  const { fromId, toId, amount } = yield* getJsonBody()

  yield* Effect.tryPromise(() =>
    db.transaction(async (tx) => {
      // Deduct from sender
      await tx.update(accounts)
        .set({ balance: sql`balance - ${amount}` })
        .where(eq(accounts.id, fromId))

      // Add to receiver
      await tx.update(accounts)
        .set({ balance: sql`balance + ${amount}` })
        .where(eq(accounts.id, toId))
    })
  )

  return json({ success: true })
})
```

## Relationships

Query related data with joins:

```typescript
const getPostWithAuthor = Effect.gen(function* () {
  const db = yield* Database
  const id = yield* getParam("id")

  const post = yield* Effect.tryPromise(() =>
    db.query.posts.findFirst({
      where: eq(posts.id, id),
      with: {
        author: true  // Include the author
      }
    })
  )

  return json(post)
})
```

## Pagination

```typescript
const listUsers = Effect.gen(function* () {
  const db = yield* Database
  const page = yield* getQueryAsNumber("page", 1)
  const limit = yield* getQueryAsNumber("limit", 20)

  const users = yield* Effect.tryPromise(() =>
    db.select()
      .from(schema.users)
      .limit(limit)
      .offset((page - 1) * limit)
  )

  return json(users)
})
```

## Migrations

Generate and run migrations:

```bash
# Generate migration from schema changes
npx drizzle-kit generate:pg

# Apply migrations to database
npx drizzle-kit push:pg
```

Configure in `drizzle.config.ts`:

```typescript
import type { Config } from "drizzle-kit"

export default {
  schema: "./src/db/schema.ts",
  out: "./drizzle",
  driver: "pg",
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
  },
} satisfies Config
```

## Testing

Use a test database:

```typescript
const TestDatabaseLive = Layer.scoped(
  Database,
  Effect.gen(function* () {
    const pool = new Pool({
      connectionString: "postgres://localhost/myapp_test"
    })
    return drizzle(pool, { schema })
  })
)

// Run tests with test database
await runEffect(handler, TestDatabaseLive)
```

<Callout type="info">
For more on Drizzle ORM, see the [official documentation](https://orm.drizzle.team/docs/overview).
</Callout>
