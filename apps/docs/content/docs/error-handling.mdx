---
title: Error Handling
description: Handle errors gracefully and return proper HTTP responses
---

import { Callout } from 'fumadocs-ui/components/callout';

Gello uses typed errors so you always know what can go wrong. Errors are converted to HTTP responses automatically or can be handled explicitly.

## Throwing Errors

Return an error from your handler:

```typescript
import { Data, Effect } from "effect"

// Define an error type
class NotFoundError extends Data.TaggedError("NotFoundError")<{
  resource: string
  id: string
}> {}

const getUser = Effect.gen(function* () {
  const id = yield* getParam("id")
  const user = yield* UserRepo.findById(id)

  if (!user) {
    return yield* new NotFoundError({ resource: "User", id })
  }

  return json(user)
})
```

## Catching Errors

Handle specific errors and return appropriate responses:

```typescript
const handler = Effect.gen(function* () {
  const user = yield* getUser(id)
  return json(user)
}).pipe(
  Effect.catchTag("NotFoundError", (error) =>
    Effect.succeed(notFound({
      error: `${error.resource} not found`,
    }))
  )
)
```

## Common Error Types

Define errors for your application:

```typescript
class ValidationError extends Data.TaggedError("ValidationError")<{
  field: string
  message: string
}> {}

class UnauthorizedError extends Data.TaggedError("UnauthorizedError")<{
  reason: string
}> {}

class ForbiddenError extends Data.TaggedError("ForbiddenError")<{
  action: string
}> {}
```

## Handling Multiple Errors

```typescript
const handler = Effect.gen(function* () {
  // ... your code
}).pipe(
  Effect.catchTags({
    NotFoundError: (e) =>
      Effect.succeed(notFound({ error: `${e.resource} not found` })),

    ValidationError: (e) =>
      Effect.succeed(badRequest({ error: e.message, field: e.field })),

    UnauthorizedError: (e) =>
      Effect.succeed(unauthorized({ error: e.reason })),
  })
)
```

## Global Error Handler

Create a middleware that handles all errors:

```typescript
const handleErrors = <R>(
  handler: Effect.Effect<HttpServerResponse, AppError, R>
) =>
  handler.pipe(
    // Handle known errors
    Effect.catchTags({
      NotFoundError: (e) =>
        Effect.succeed(notFound({ error: `${e.resource} not found` })),
      ValidationError: (e) =>
        Effect.succeed(badRequest({ error: e.message })),
      UnauthorizedError: () =>
        Effect.succeed(unauthorized({ error: "Please log in" })),
    }),

    // Handle unexpected errors
    Effect.catchAllDefect((error) => {
      console.error("Unexpected error:", error)
      return Effect.succeed(internalError({ error: "Something went wrong" }))
    })
  )

// Apply to routes
const routes = [
  route.get("/users/:id", handleErrors(getUser)),
  route.post("/users", handleErrors(createUser)),
]
```

## Validation Errors

Schema validation errors are handled specially:

```typescript
const createUser = Effect.gen(function* () {
  const body = yield* parseBody(CreateUser)
  // ...
}).pipe(
  Effect.catchTag("ParseError", (error) => {
    const issues = formatValidationErrors(error)
    return Effect.succeed(badRequest({
      error: "Validation failed",
      issues,
    }))
  })
)
```

## Using the Error Handler Middleware

Gello includes a built-in error handler:

```typescript
import { errorHandler } from "@gello/common"

const app = createApp({ port: 3000 })
  .use(errorHandler())  // Converts errors to HTTP responses
  .routes([...])
```

This middleware:
- Converts known error types to appropriate HTTP status codes
- Returns JSON error responses
- Logs unexpected errors
- Hides internal details in production

## Tips

### Keep Errors Specific

```typescript
// Good — specific and actionable
class UserNotFoundError extends Data.TaggedError("UserNotFoundError")<{
  userId: string
}> {}

// Less good — too generic
class NotFoundError extends Data.TaggedError("NotFoundError")<{
  message: string
}> {}
```

### Include Context

```typescript
// Include information that helps debugging
class PaymentFailedError extends Data.TaggedError("PaymentFailedError")<{
  orderId: string
  amount: number
  reason: string
  provider: string
}> {}
```

### Let Errors Bubble

You don't need to catch every error — let them bubble up to a global handler:

```typescript
// Individual route — just throw errors
const getUser = Effect.gen(function* () {
  const user = yield* UserRepo.findById(id)
  if (!user) return yield* new NotFoundError({ resource: "User", id })
  return json(user)
})

// Global handler catches everything
app.use(errorHandler())
```

<Callout type="info">
The error handler middleware shows full error details in development and minimal details in production for security.
</Callout>
