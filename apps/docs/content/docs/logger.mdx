---
title: Logger
description: A comprehensive logging solution with multiple drivers, following hexagonal DDD architecture. Built on Effect with pretty printing, structured JSON output, and file rotation.
---

import { Callout } from 'fumadocs-ui/components/callout';

## Architecture Overview

The logger follows a **Ports & Adapters** (hexagonal) architecture pattern,
separating concerns into three layers:

- **Contracts (Ports)** - Interfaces defining the logging API
- **Domain** - Core logging logic, formatters, and entry creation
- **Adapters (Drivers)** - Concrete implementations for different outputs

## Quick Start

```typescript
import { Effect } from "effect";
import { Logger, developmentLogger, logInfo } from "@gello/core-config";

// Use the development preset (pretty console output)
const program = Effect.gen(function* () {
  yield* logInfo("Application started", { version: "1.0.0" });

  // Your application logic here
});

// Run with the logger layer
Effect.runPromise(
  program.pipe(Effect.provide(developmentLogger()))
);
```

## Log Levels

```typescript
type LogLevel = "trace" | "debug" | "info" | "warning" | "error" | "fatal";

// Level ordering (lowest to highest severity)
// trace < debug < info < warning < error < fatal

// Check if a level should be logged
import { shouldLog } from "@gello/core-contracts";

shouldLog("debug", "info");  // false (debug < info minimum)
shouldLog("error", "info");  // true  (error >= info minimum)
```

## Using the Logger

```typescript
import { Effect } from "effect";
import { Logger } from "@gello/core-contracts";

// Access logger from context
const program = Effect.gen(function* () {
  const logger = yield* Logger;

  // Log at different levels
  yield* logger.trace("Detailed trace info");
  yield* logger.debug("Debug information", { userId: 123 });
  yield* logger.info("User logged in", { email: "user@example.com" });
  yield* logger.warning("Rate limit approaching", { current: 95, max: 100 });
  yield* logger.error("Failed to process", new Error("Connection timeout"), {
    retryCount: 3
  });
  yield* logger.fatal("System shutdown required", new Error("Out of memory"));
});

// Or use the convenience helpers
import { logInfo, logError, logDebug } from "@gello/core-config";

const simpler = Effect.gen(function* () {
  yield* logInfo("Processing request", { requestId: "abc-123" });
  yield* logError("Operation failed", new Error("timeout"), { attempt: 3 });
});
```

## Child Loggers & Context

<Callout type="info">
Create child loggers with inherited context for request scoping.
All logs from a child logger include the parent context.
</Callout>

```typescript
const handleRequest = (requestId: string) =>
  Effect.gen(function* () {
    const logger = yield* Logger;

    // Create a child logger with request context
    const reqLogger = logger
      .withRequestId(requestId)
      .withService("api")
      .withModule("users");

    // All logs from this logger include the context
    yield* reqLogger.info("Processing user request");
    // Output: [api/users] (abc-123) Processing user request

    yield* reqLogger.debug("Fetching user data", { userId: 42 });
    // Output: [api/users] (abc-123) Fetching user data { userId: 42 }

    // Or add arbitrary context
    const orderLogger = reqLogger.child({ orderId: "order-999" });
    yield* orderLogger.info("Order processed");
  });
```

## Drivers

### Console Driver

Simple colorized output to stdout/stderr:

```typescript
import { consoleDriver } from "@gello/adapters-logger";

const driver = consoleDriver({
  colors: true,      // ANSI color codes
  timestamps: true,  // Include timestamps
});
```

### Pretty Driver

Human-readable output with icons and colors:

```typescript
import { prettyDriver } from "@gello/adapters-logger";

const driver = prettyDriver({
  colors: true,     // ANSI colors
  icons: true,      // Level icons (●, ⚠, ✖, etc.)
  timestamps: true, // HH:MM:SS.mmm format
  multiline: true,  // Pretty-print context objects
});

// Output example:
// 14:32:45.123 ● INFO    [api/users] (req-123) User logged in
//     {
//       "email": "user@example.com",
//       "ip": "192.168.1.1"
//     }
```

### JSON Driver

Structured JSON for log aggregators (ELK, Datadog, etc.):

```typescript
import { jsonDriver } from "@gello/adapters-logger";

const driver = jsonDriver({
  includeStack: true,  // Include stack traces for errors
});

// Output example:
// {"timestamp":"2024-01-15T14:32:45.123Z","level":"info","message":"User logged in"}
```

### File Driver

Write to files with automatic rotation and compression:

```typescript
import { Effect, Scope } from "effect";
import { fileDriver } from "@gello/adapters-logger";

// File driver requires a Scope for resource management
const program = Effect.scoped(
  Effect.gen(function* () {
    const driver = yield* fileDriver({
      path: "./logs/app.log",
      maxSize: 50 * 1024 * 1024,  // 50MB before rotation
      maxFiles: 10,               // Keep 10 rotated files
      compress: true,             // Gzip old files
    });

    // Use the driver...
  })
);
```

### Multi Driver

Combine multiple drivers for simultaneous output:

```typescript
import { multiDriver, prettyDriver, jsonDriver } from "@gello/adapters-logger";

// Log to both console (pretty) and stdout (JSON)
const driver = multiDriver([
  prettyDriver({ colors: true, icons: true }),
  jsonDriver({ includeStack: true }),
]);
```

## Environment Presets

```typescript
import {
  developmentLogger,
  productionLogger,
  testLogger,
  stagingLogger,
  environmentLogger
} from "@gello/core-config";

// Development: Pretty console output, debug level
const devLayer = developmentLogger();

// Production: JSON to stdout + rotating file, info level
const prodLayer = productionLogger("./logs/app.log");

// Testing: Null driver, fatal level only
const testLayer = testLogger();

// Staging: JSON output, warning level minimum
const stagingLayer = stagingLogger();

// Auto-detect from NODE_ENV
const autoLayer = environmentLogger();
```

## Testing with Mock Logger

```typescript
import {
  createMockLogger,
  withMockLogger,
  silentLoggerLayer,
  expectLogEntry,
  expectNoErrors,
} from "@gello/testing-mocks";

// Option 1: Use withMockLogger helper
const testProgram = Effect.gen(function* () {
  const { result, logs } = yield* withMockLogger(
    myFunction()
  );

  // Assert on captured logs
  expectLogEntry(logs, {
    level: "info",
    messageContains: "processed"
  });
  expectNoErrors(logs);

  return result;
});

// Option 2: Silent logger (no capture, just discard)
const silentTest = myFunction().pipe(
  Effect.provide(silentLoggerLayer)
);
```

## Redaction

Automatically redact sensitive data from logs:

```typescript
import { makeLogger } from "@gello/domain-logger";
import { prettyDriver } from "@gello/adapters-logger";

const logger = makeLogger(
  prettyDriver({ colors: true }),
  {
    level: "debug",
    service: "api",
    redactKeys: [
      "password",
      "token",
      "secret",
      "authorization",
      "cookie",
      "creditCard"
    ],
  }
);

// Sensitive values are replaced with [REDACTED]
yield* logger.info("User login", {
  email: "user@example.com",
  password: "secret123",  // Logged as: [REDACTED]
  token: "abc123",        // Logged as: [REDACTED]
});
```

## Best Practices

- **Use child loggers** for request scoping — attach `requestId` early
  and all subsequent logs will include it
- **Structure your context** — use consistent keys like `userId`,
  `orderId`, `duration` for easier log aggregation
- **Use appropriate levels** — `debug` for development,
  `info` for business events, `error` for actionable issues
- **Configure redaction** — always redact sensitive fields like passwords,
  tokens, and PII
- **Use JSON in production** — structured logs work better with log aggregators
  and make searching/alerting easier
