---
title: Middleware
description: Process requests before and after your handlers
---

import { Callout } from 'fumadocs-ui/components/callout';

Middleware lets you run code before and after route handlers. Use it for authentication, logging, CORS, and more.

## Using Middleware

Add middleware to your app:

```typescript
import { cors, logging, errorHandler } from "@gello/common"

const app = createApp({ port: 3000 })
  .use(logging())       // Log all requests
  .use(cors())          // Add CORS headers
  .use(errorHandler())  // Convert errors to responses
  .routes([...])
```

## Built-in Middleware

### Logging

Logs incoming requests and their responses:

```typescript
import { logging } from "@gello/common"

app.use(logging())

// Output:
// [INFO] GET /api/users 200 45ms
// [INFO] POST /api/posts 201 120ms
```

### CORS

Add Cross-Origin Resource Sharing headers:

```typescript
import { cors } from "@gello/common"

// Allow all origins
app.use(cors())

// Specific origins
app.use(cors({
  origins: ["https://myapp.com", "https://admin.myapp.com"],
  methods: ["GET", "POST", "PUT", "DELETE"],
  headers: ["Content-Type", "Authorization"],
}))
```

### Timing

Add response time headers:

```typescript
import { timing } from "@gello/common"

app.use(timing())

// Adds X-Response-Time header to all responses
```

### Error Handler

Convert errors to HTTP responses:

```typescript
import { errorHandler } from "@gello/common"

app.use(errorHandler())
```

## Route Group Middleware

Apply middleware to specific route groups:

```typescript
import { authenticate } from "@gello/auth"

// Public routes — no middleware
const publicRoutes = [
  route.get("/health", healthCheck),
  route.post("/login", login),
]

// Protected routes — require authentication
const protectedRoutes = Route.group({
  prefix: "/api",
  middleware: [authenticate()],
}, [
  route.get("/me", getCurrentUser),
  route.get("/settings", getSettings),
])

// Admin routes — require auth + admin role
const adminRoutes = Route.group({
  prefix: "/admin",
  middleware: [authenticate(), requireAdmin()],
}, [
  route.get("/users", listAllUsers),
  route.delete("/users/:id", deleteUser),
])
```

## Writing Custom Middleware

A middleware is a function that wraps a handler:

```typescript
import { Effect } from "effect"
import type { Middleware } from "@gello/common"

const myMiddleware: Middleware = {
  name: "myMiddleware",
  apply: (handler) =>
    Effect.gen(function* () {
      // Before the handler
      console.log("Request started")

      // Run the handler
      const response = yield* handler

      // After the handler
      console.log("Request completed")

      return response
    }),
}

app.use(myMiddleware)
```

### Add Headers

```typescript
const addHeaders: Middleware = {
  name: "addHeaders",
  apply: (handler) =>
    Effect.gen(function* () {
      const response = yield* handler
      return response.pipe(
        HttpServerResponse.setHeader("X-Powered-By", "Gello"),
        HttpServerResponse.setHeader("X-Request-Id", crypto.randomUUID()),
      )
    }),
}
```

### Authentication

```typescript
const requireAuth: Middleware = {
  name: "requireAuth",
  apply: (handler) =>
    Effect.gen(function* () {
      const token = yield* getBearerToken()

      if (!token) {
        return unauthorized({ error: "Missing token" })
      }

      const user = yield* verifyToken(token)

      // Make user available to the handler
      return yield* handler.pipe(
        Effect.provideService(CurrentUser, user)
      )
    }),
}
```

### Rate Limiting

```typescript
const rateLimit = (maxRequests: number, window: string): Middleware => ({
  name: "rateLimit",
  apply: (handler) =>
    Effect.gen(function* () {
      const ip = yield* getClientIp()
      const cache = yield* Cache

      const key = `ratelimit:${ip}`
      const count = yield* cache.increment(key)

      if (count === 1) {
        yield* cache.expire(key, window)
      }

      if (count > maxRequests) {
        return json({ error: "Too many requests" }, { status: 429 })
      }

      return yield* handler
    }),
})

app.use(rateLimit(100, "1 minute"))
```

## Middleware Order

Middleware runs in the order it's added:

```typescript
app
  .use(logging())      // 1. Log the request
  .use(cors())         // 2. Add CORS headers
  .use(rateLimit())    // 3. Check rate limit
  .use(authenticate()) // 4. Authenticate user
  .use(errorHandler()) // 5. Handle errors
```

For route groups, global middleware runs first, then group middleware:

```typescript
// Order: logging → cors → authenticate → handler
app.use(logging()).use(cors())

Route.group({
  middleware: [authenticate()],
}, [...])
```

<Callout type="info">
Put the error handler last so it can catch errors from all other middleware.
</Callout>
