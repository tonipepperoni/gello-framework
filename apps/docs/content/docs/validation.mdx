---
title: Validation
description: Validate request data with type-safe schemas
---

import { Callout } from 'fumadocs-ui/components/callout';

Gello uses `@effect/schema` for validation. Define a schema once and get both runtime validation and TypeScript types.

## Basic Usage

```typescript
import * as S from "@effect/schema/Schema"

// Define a schema
const CreateUser = S.Struct({
  name: S.String.pipe(S.minLength(2), S.maxLength(100)),
  email: S.String.pipe(S.pattern(/@/)),
  age: S.optional(S.Number.pipe(S.int(), S.positive())),
})

// TypeScript type is inferred automatically
type CreateUser = S.Schema.Type<typeof CreateUser>
// { name: string; email: string; age?: number }
```

## Validating Request Body

```typescript
const createUser = Effect.gen(function* () {
  // Validates and parses the JSON body
  const body = yield* parseBody(CreateUser)

  // body is fully typed â€” TypeScript knows it matches CreateUser
  const user = yield* UserRepo.create(body)

  return created(user)
})
```

If validation fails, Gello returns a 400 response with error details.

## Path Parameters

```typescript
const UserIdParam = S.Struct({
  id: S.String.pipe(S.pattern(/^[a-f0-9-]{36}$/)),  // UUID format
})

const getUser = Effect.gen(function* () {
  const { id } = yield* parseParams(UserIdParam)

  const user = yield* UserRepo.findById(id)
  return json(user)
})
```

## Query Parameters

```typescript
const PaginationQuery = S.Struct({
  page: S.optional(S.NumberFromString).pipe(S.withDefault(() => 1)),
  limit: S.optional(S.NumberFromString).pipe(S.withDefault(() => 20)),
  sort: S.optional(S.Literal("asc", "desc")).pipe(S.withDefault(() => "desc" as const)),
})

const listUsers = Effect.gen(function* () {
  const query = yield* parseQuery(PaginationQuery)
  // query: { page: number; limit: number; sort: "asc" | "desc" }

  const users = yield* UserRepo.list(query)
  return json(users)
})
```

## Common Validators

```typescript
// String constraints
S.String.pipe(S.minLength(2))
S.String.pipe(S.maxLength(100))
S.String.pipe(S.pattern(/^[a-z]+$/))
S.String.pipe(S.nonEmpty())

// Number constraints
S.Number.pipe(S.positive())
S.Number.pipe(S.int())
S.Number.pipe(S.between(1, 100))

// Enums
S.Literal("pending", "approved", "rejected")

// Optional with defaults
S.optional(S.String).pipe(S.withDefault(() => "default"))

// Arrays
S.Array(S.String)
S.Array(S.String).pipe(S.minItems(1))
```

## Custom Validators

```typescript
// Email validation
const Email = S.String.pipe(
  S.filter((s) => s.includes("@") && s.includes("."), {
    message: () => "Invalid email format",
  })
)

// Password with requirements
const Password = S.String.pipe(
  S.minLength(8),
  S.filter((s) => /[A-Z]/.test(s), {
    message: () => "Must contain an uppercase letter",
  }),
  S.filter((s) => /[0-9]/.test(s), {
    message: () => "Must contain a number",
  })
)

// URL slug
const Slug = S.String.pipe(
  S.pattern(/^[a-z0-9-]+$/),
  S.minLength(3),
  S.maxLength(50)
)
```

## Transformations

Transform data during validation:

```typescript
// Trim whitespace
const TrimmedString = S.String.pipe(
  S.transform(S.String, {
    decode: (s) => s.trim(),
    encode: (s) => s,
  })
)

// Parse date from string
const DateFromString = S.String.pipe(
  S.transform(S.Date, {
    decode: (s) => new Date(s),
    encode: (d) => d.toISOString(),
  })
)
```

## Reusable Schemas

Create a schema library for your app:

```typescript
// schemas/user.ts
export const UserBase = S.Struct({
  name: S.String.pipe(S.minLength(2)),
  email: Email,
})

export const CreateUser = UserBase.pipe(
  S.extend(S.Struct({
    password: Password,
  }))
)

export const UpdateUser = S.partial(UserBase)

export const User = UserBase.pipe(
  S.extend(S.Struct({
    id: S.String,
    createdAt: S.Date,
  }))
)
```

## Error Messages

Validation errors include helpful details:

```json
{
  "error": "Validation failed",
  "issues": [
    { "path": "name", "message": "Expected string with at least 2 characters" },
    { "path": "email", "message": "Invalid email format" }
  ]
}
```

<Callout type="info">
Schemas validate on the way in (decoding) and can also validate on the way out (encoding). Use `schemaJson` for response validation.
</Callout>
